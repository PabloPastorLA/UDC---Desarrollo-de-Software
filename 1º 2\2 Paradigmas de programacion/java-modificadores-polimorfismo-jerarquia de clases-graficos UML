Caracteres Ãºtiles
â†’
--------------------------------------------------------------------------------------------------------------------------------------

Modificadores
Â¿Usa static?	Tipo de atributo								Modificadores posibles
SÃ­ (static)		De clase (uno solo, compartido por todos los objetos)		private, protected, public, default
No (static)		De instancia (cada objeto tiene su copia)				private, protected, public, default


âœ… Entonces:

static 				decide si es de clase o de instancia.
private/protected/public 	deciden la visibilidad, de mas a menos estricto.

final				define valor constante (por convencion los nombres de las ctes van en MAYUSCULA y espacios con un _ )
				ej:	static public final AÃ‘O_ACTUAL = 2025

--------------------------------------------------------------------------------------------------------------------------------------

OBJETOS: ES-UN vs TIENE-UN
ES-UN (auto es un vehiculo) 		(es un tipo de otro) (se refleja con extends, osea superclase y subclase)
TIENE-UN (vehiculo tiene un dueÃ±o) 	(tiene otro como parte de sÃ­ mismo.) (atributo dentro de la clase.)

--------------------------------------------------------------------------------------------------------------------------------------
INTERFACES:
es un contrato, una "obligacion" de implementacion.
//definimos o declaramos la interface:

public interface NombreDeLaInterface {
    // mÃ©todos abstractos (solo firmas, sin cuerpo) (SI O SI Nombre, tipo de retorno, y lista de parametros (tipo de parametro y nombre en orden))
    void metodo1();
    int metodo2(String parametro);
}




//la clase "Implementa" la interface:

public class Clase implements Interface{
	@Override
	public void metodoFirmadoEnInterface() {
}



@Override solo va en mÃ©todos que estÃ¡s implementando o sobrescribiendo (de una interface o superclase).
--------------------------------------------------------------------------------------------------------------------------------------

@Override:
Override = sobreescribir.

Cuando por herencia una sub sobreescribe un metodo de una super, u otra sub o super sobreescribe el de la interface implementada
se puede escribir en el renglon anterior @Override (la O con mayuscula). No es obligatorio pero recomendable porque sirve para
que el compilador nos avise de posibles errores en el nombre del metodo a sobreescribir.
--------------------------------------------------------------------------------------------------------------------------------------

QuÃ© es el tipo lÃ©xico?

Tipo lÃ©xico (o estÃ¡tico, declarado):
Es el tipo que vos escribÃ­s a la izquierda cuando declarÃ¡s la variable.
Se conoce en tiempo de compilaciÃ³n.
Define quÃ© mÃ©todos y atributos son accesibles sin casting.

Tipo dinÃ¡mico (o real):
Es el tipo del objeto creado con new (a la derecha).
Se conoce en tiempo de ejecuciÃ³n.
Define quÃ© implementaciÃ³n se ejecuta cuando un mÃ©todo estÃ¡ sobrescrito.

	Ejemplo con tu jerarquÃ­a:

	Encomienda encomienda = new Contrareembolso();

	Tipo lÃ©xico: Encomienda
	Tipo dinÃ¡mico: Contrareembolso
	
--------------------------------------------------------------------------------------------------------------------------------------


Los grÃ¡ficos que muestran clases y flechas entre ellas se llaman diagramas de clases UML (Unified Modeling Language).
Son parte de UML, un estÃ¡ndar visual para representar sistemas orientados a objetos.

Las flechas suelen indicar herencia (generalizaciÃ³n/especializaciÃ³n) o implementaciÃ³n de interfaces.

ğŸ“Œ En UML:

Una flecha con triÃ¡ngulo blanco apuntando hacia arriba indica herencia:

Contrareembolso â”€â–· Encomienda â”€â–· Envio significa que Contrareembolso extends Encomienda, y Encomienda extends Envio.

Una lÃ­nea punteada con triÃ¡ngulo blanco significa implementaciÃ³n de interfaz.




Mini-diagrama UML de tu caso:

	â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
	â”‚   Envio         â”‚  <<abstract>>
	â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		 â–²
		 â”‚
	â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
	â”‚  Encomienda     â”‚
	â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		 â–²
		 â”‚
	â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
	â”‚ Contrareembolso â”‚
	â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


----------	otra info	------------
https://catedu.github.io/poo-java/jerarqua_de_clases.html

 
--------------------------------------------------------------------------------------------------------------------------------------

Clase Abstracta:

	Una clase abstracta es un molde incompleto.
	No se puede instanciar.
	Puede tener mÃ©todos abstractos y normales.
	Sirve para generalizar y aprovechar herencia + polimorfismo.

Â¿En una interfaz el mÃ©todo tambiÃ©n puede ser abstracto?
	SÃ­, todos los mÃ©todos en una interfaz son abstractos por defecto (a menos que sean default o static).
	Por eso no se escribe abstract, es implÃ­cito.

Â¿La clase abstracta puede tener atributos?
	SÃ­. Una clase abstracta puede tener atributos, mÃ©todos concretos (con cuerpo), y mÃ©todos abstractos (sin cuerpo).

Â¿Los mÃ©todos abstract deben ser sÃ­ o sÃ­ implementados en las subclases?
	Exacto. La idea principal es esa: obligar a las subclases a dar su propia implementaciÃ³n.
	Si no implementÃ¡s el mÃ©todo, la subclase tambiÃ©n debe ser abstracta.

Â¿Una clase abstracta sÃ­ o sÃ­ debe tener una subclase?
	En la prÃ¡ctica, sÃ­ (porque si no, nunca podrÃ­as instanciar nada de esa jerarquÃ­a).
	Pero el compilador no te obliga a crear una subclase; simplemente, si no lo hacÃ©s, esa clase abstracta queda â€œinutilizableâ€ por sÃ­ sola.

Â¿No se puede instanciar porque posee mÃ©todos sin cuerpo?
	SÃ­, esa es la razÃ³n fundamental. serÃ­a imposible ejecutar el llamado a un mÃ©todo abstracto sin cuerpo

Â¿Si la clase posee un mÃ©todo abstracto, debe ser sÃ­ o sÃ­ abstracta? Correcto.
	abstract class Envio {
	    abstract double calcularImpuesto();


--------------------------------------------------------------------------------------------------------------------------------------

Clase abstracta vs Interfaz

CaracterÃ­stica	Clase abstracta								Interfaz
InstanciaciÃ³n	âŒ No se puede instanciar						âŒ No se puede instanciar
Atributos		âœ… Puede tener atrib (variables de instancia, normales)	âš ï¸ Solo constantes
MÃ©tods abstractos	âœ… Puede tener mÃ©todos abstractos					âœ… Son abstractos por defecto
MÃ©tods con cuerpo	âœ… SÃ­, puede tener mÃ©todos con cuerpo				âœ… Puede tener default y static con cÃ³digo
Constructores	âœ… Puede tener (pero no se instancian directamente)		âŒ No puede tener constructores
Herencia		Una clase solo extiende 1 clase abs. (herencia simple)	Una clase puede implementar muchas interfaces (herencia mÃºltiple)
Uso tÃ­pico		Cuando querÃ©s un molde comÃºn con atrib y metodos		Para definir un contrato que varias clases distintas deben cumplir


âœ… Resumiendo:

UsÃ¡s clase abstracta cuando tenÃ©s un concepto general que comparte atributos y algunos mÃ©todos comunes.
UsÃ¡s interfaz cuando querÃ©s un contrato (cierta obligacion de comportamiento) sin importar atributos ni herencia.
--------------------------------------------------------------------------------------------------------------------------------------

En Java un mÃ©todo static no puede ser abstract.
RazÃ³n: un mÃ©todo abstract no tiene cuerpo y debe implementarse en una subclase.

Un mÃ©todo static pertenece a la interfaz o clase misma, no a ninguna instancia ni subclase, asÃ­ que no tiene sentido dejarlo sin implementaciÃ³n.


abstract = sin cuerpo â†’ necesita implementaciÃ³n en subclaseâ€
â€œstatic = pertenece a la interfaz/clase â†’ ya tiene cuerpo, no necesita implementaciÃ³nâ€

--------------------------------------------------------------------------------------------------------------------------------------


En Java, el polimorfismo estÃ¡ diseÃ±ado para los mÃ©todos de instancia, no para los atributos.

MÃ©todos de instancia	âœ… SÃ­	Tiempo de ejecuciÃ³n (runtime, tipo dinÃ¡mico del objeto)
Atributos			âŒ No	Tiempo de compilaciÃ³n (compile-time, tipo lÃ©xico de la variable)
MÃ©todos estÃ¡ticos		âŒ No	Compile-time, por la clase a la que se llame




con estas clases:
	----
class Animal {
    void sonido() { System.out.println("Sonido genÃ©rico"); }
}

class Perro extends Animal {
    @Override
    void sonido() { System.out.println("Guau"); }
}
	----

cuando hacemos esto:
	----
Animal a = new Perro();
a.sonido(); // ğŸ‘‰ "Guau" (se ejecuta el de Perro)
	----
sale guau, no sale sonido generico

	
--------------------------------------------------------------------------------------------------------------------------------------


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
ğŸ”¹ 1. Clase variable = new Clase(); âœ… (lo mÃ¡s simple)

Esto es lo normal y directo:

La variable es del mismo tipo que el objeto que instanciÃ¡s.

PodÃ©s usar todos los atributos y mÃ©todos de la clase.

Ejemplo:
	----
Perro p = new Perro();
p.ladrar();  // âœ… se puede
	----
ğŸ‘‰ Nada de polimorfismo acÃ¡, solo instanciaciÃ³n directa.

ğŸ”¹ 2. Subclase variable = new Subclase(); âœ…

Esto tambiÃ©n es muy simple:

La variable es de tipo subclase, y el objeto tambiÃ©n.

Acceso completo a todo lo que tenga la subclase (incluyendo lo heredado de la superclase).

Ejemplo:


class Animal { void mover() {} }
class Perro extends Animal { void ladrar() {} }

Perro p = new Perro();
p.ladrar(); // âœ… propio de Perro
p.mover();  // âœ… heredado de Animal


ğŸ‘‰ Igual que el caso anterior, pero con herencia de por medio.

ğŸ”¹ 3. Superclase variable = new Superclase(); âœ…

Ahora con herencia:

La variable es de tipo superclase y el objeto tambiÃ©n.

Solo podÃ©s acceder a lo definido en la superclase.

Si la superclase es abstracta â†’ âŒ no podÃ©s instanciarla.

Ejemplo:


Animal a = new Animal();
a.mover(); // âœ…
a.ladrar(); // âŒ no existe en Animal

ğŸ‘‰ Directo, pero ojo: si Animal es abstracta, esto no se puede.

ğŸ”¹ 4. Superclase variable = new Subclase(); âœ… (el mÃ¡s interesante: polimorfismo)

Este es el patrÃ³n tÃ­pico de polimorfismo en Java:

La variable es del tipo superclase.

El objeto real es de tipo subclase.

PodÃ©s solo acceder a lo definido en la superclase, PERO si un mÃ©todo fue sobrescrito, se ejecuta el de la subclase real.

Ejemplo:

Animal a = new Perro();
a.mover();   // âœ… mÃ©todo de Animal, pero si Perro lo sobrescribe se ejecuta el de Perro
// a.ladrar(); // âŒ no compila, porque "ladrar" no existe en Animal


ğŸ‘‰ AcÃ¡ estÃ¡ la potencia: podÃ©s manejar distintos tipos de subclases con una sola referencia de superclase.

ğŸ”¹ Resumen en orden de simple a complejo

Clase variable = new Clase();
â†’ instanciaciÃ³n directa, acceso completo.

Subclase variable = new Subclase();
â†’ igual que arriba, con herencia incluida.

Superclase variable = new Superclase();
â†’ vÃ¡lido salvo que la superclase sea abstracta.

Superclase variable = new Subclase();
â†’ polimorfismo: referencia de superclase, objeto real de subclase.

ğŸ‘‰ Â¿QuerÃ©s que te arme un ejemplo con cÃ³digo donde aparezcan los 4 casos juntos, para ver lado a lado cÃ³mo compilan y quÃ© se puede hacer en cada uno?


class Animal {
    void mover() {
        System.out.println("El animal se mueve");
    }
}

class Perro extends Animal {
    @Override
    void mover() {
        System.out.println("El perro corre");
    }

    void ladrar() {
        System.out.println("Â¡Guau!");
    }
}

public class Test {
    public static void main(String[] args) {
        
        // 1) Clase = Clase (directo)
        Animal a1 = new Animal();
        a1.mover(); // "El animal se mueve"
        // a1.ladrar(); âŒ ERROR, no existe en Animal
        
        // 2) Subclase = Subclase
        Perro p1 = new Perro();
        p1.mover();  // "El perro corre" (override)
        p1.ladrar(); // "Â¡Guau!" (propio de Perro)
        
        // 3) Superclase = Superclase
        Animal a2 = new Animal();
        a2.mover(); // "El animal se mueve"
        // a2.ladrar(); âŒ no existe en Animal
        
        // 4) Superclase = Subclase (polimorfismo)
        Animal a3 = new Perro();
        a3.mover();  // "El perro corre" (se ejecuta el de Perro)
        // a3.ladrar(); âŒ no compila (no estÃ¡ en Animal)
        
        // Si quiero ladrar desde a3, necesito casting:
        ((Perro)a3).ladrar(); // "Â¡Guau!"
    }
}




ğŸ”¹ ExplicaciÃ³n rÃ¡pida de cada caso

Clase = Clase

InstanciaciÃ³n directa.

Nada raro, acceso total a lo que define la clase.

Subclase = Subclase

Lo mÃ¡s flexible: acceso a mÃ©todos heredados y propios.

Superclase = Superclase

Solo acceso a lo de la superclase.

Nada polimÃ³rfico.

Superclase = Subclase (polimorfismo)

La variable solo â€œveâ€ lo de la superclase.

Pero si un mÃ©todo estÃ¡ sobrescrito, en ejecuciÃ³n corre la versiÃ³n de la subclase.

ğŸ’¡ Regla de oro:

Atributos y mÃ©todos estÃ¡ticos â†’ se resuelven por el tipo de la variable (lÃ©xico).

MÃ©todos de instancia sobrescritos â†’ se resuelven por el tipo real del objeto (dinÃ¡mico).



