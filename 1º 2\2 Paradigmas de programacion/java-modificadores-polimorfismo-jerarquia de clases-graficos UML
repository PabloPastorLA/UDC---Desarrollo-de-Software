Caracteres útiles
→
--------------------------------------------------------------------------------------------------------------------------------------

Modificadores
¿Usa static?	Tipo de atributo								Modificadores posibles
Sí (static)		De clase (uno solo, compartido por todos los objetos)		private, protected, public, default
No (static)		De instancia (cada objeto tiene su copia)				private, protected, public, default


✅ Entonces:

static 				decide si es de clase o de instancia.
private/protected/public 	deciden la visibilidad, de mas a menos estricto.

final				define valor constante (por convencion los nombres de las ctes van en MAYUSCULA y espacios con un _ )
				ej:	static public final AÑO_ACTUAL = 2025

--------------------------------------------------------------------------------------------------------------------------------------

OBJETOS: ES-UN vs TIENE-UN
ES-UN (auto es un vehiculo) 		(es un tipo de otro) (se refleja con extends, osea superclase y subclase)
TIENE-UN (vehiculo tiene un dueño) 	(tiene otro como parte de sí mismo.) (atributo dentro de la clase.)

--------------------------------------------------------------------------------------------------------------------------------------
INTERFACES:
es un contrato, una "obligacion" de implementacion.
//definimos o declaramos la interface:

public interface NombreDeLaInterface {
    // métodos abstractos (solo firmas, sin cuerpo) (SI O SI Nombre, tipo de retorno, y lista de parametros (tipo de parametro y nombre en orden))
    void metodo1();
    int metodo2(String parametro);
}




//la clase "Implementa" la interface:

public class Clase implements Interface{
	@Override
	public void metodoFirmadoEnInterface() {
}



@Override solo va en métodos que estás implementando o sobrescribiendo (de una interface o superclase).
--------------------------------------------------------------------------------------------------------------------------------------

@Override:
Override = sobreescribir.

Cuando por herencia una sub sobreescribe un metodo de una super, u otra sub o super sobreescribe el de la interface implementada
se puede escribir en el renglon anterior @Override (la O con mayuscula). No es obligatorio pero recomendable porque sirve para
que el compilador nos avise de posibles errores en el nombre del metodo a sobreescribir.
--------------------------------------------------------------------------------------------------------------------------------------

Qué es el tipo léxico?

Tipo léxico (o estático, declarado):
Es el tipo que vos escribís a la izquierda cuando declarás la variable.
Se conoce en tiempo de compilación.
Define qué métodos y atributos son accesibles sin casting.

Tipo dinámico (o real):
Es el tipo del objeto creado con new (a la derecha).
Se conoce en tiempo de ejecución.
Define qué implementación se ejecuta cuando un método está sobrescrito.

	Ejemplo con tu jerarquía:

	Encomienda encomienda = new Contrareembolso();

	Tipo léxico: Encomienda
	Tipo dinámico: Contrareembolso
	
--------------------------------------------------------------------------------------------------------------------------------------


Los gráficos que muestran clases y flechas entre ellas se llaman diagramas de clases UML (Unified Modeling Language).
Son parte de UML, un estándar visual para representar sistemas orientados a objetos.

Las flechas suelen indicar herencia (generalización/especialización) o implementación de interfaces.

📌 En UML:

Una flecha con triángulo blanco apuntando hacia arriba indica herencia:

Contrareembolso ─▷ Encomienda ─▷ Envio significa que Contrareembolso extends Encomienda, y Encomienda extends Envio.

Una línea punteada con triángulo blanco significa implementación de interfaz.




Mini-diagrama UML de tu caso:

	┌─────────────────┐
	│   Envio         │  <<abstract>>
	└─────────────────┘
		 ▲
		 │
	┌─────────────────┐
	│  Encomienda     │
	└─────────────────┘
		 ▲
		 │
	┌─────────────────┐
	│ Contrareembolso │
	└─────────────────┘


----------	otra info	------------
https://catedu.github.io/poo-java/jerarqua_de_clases.html

 
--------------------------------------------------------------------------------------------------------------------------------------

Clase Abstracta:

	Una clase abstracta es un molde incompleto.
	No se puede instanciar.
	Puede tener métodos abstractos y normales.
	Sirve para generalizar y aprovechar herencia + polimorfismo.

¿En una interfaz el método también puede ser abstracto?
	Sí, todos los métodos en una interfaz son abstractos por defecto (a menos que sean default o static).
	Por eso no se escribe abstract, es implícito.

¿La clase abstracta puede tener atributos?
	Sí. Una clase abstracta puede tener atributos, métodos concretos (con cuerpo), y métodos abstractos (sin cuerpo).

¿Los métodos abstract deben ser sí o sí implementados en las subclases?
	Exacto. La idea principal es esa: obligar a las subclases a dar su propia implementación.
	Si no implementás el método, la subclase también debe ser abstracta.

¿Una clase abstracta sí o sí debe tener una subclase?
	En la práctica, sí (porque si no, nunca podrías instanciar nada de esa jerarquía).
	Pero el compilador no te obliga a crear una subclase; simplemente, si no lo hacés, esa clase abstracta queda “inutilizable” por sí sola.

¿No se puede instanciar porque posee métodos sin cuerpo?
	Sí, esa es la razón fundamental. sería imposible ejecutar el llamado a un método abstracto sin cuerpo

¿Si la clase posee un método abstracto, debe ser sí o sí abstracta? Correcto.
	abstract class Envio {
	    abstract double calcularImpuesto();


--------------------------------------------------------------------------------------------------------------------------------------

Clase abstracta vs Interfaz

Característica	Clase abstracta								Interfaz
Instanciación	❌ No se puede instanciar						❌ No se puede instanciar
Atributos		✅ Puede tener atrib (variables de instancia, normales)	⚠️ Solo constantes
Métods abstractos	✅ Puede tener métodos abstractos					✅ Son abstractos por defecto
Métods con cuerpo	✅ Sí, puede tener métodos con cuerpo				✅ Puede tener default y static con código
Constructores	✅ Puede tener (pero no se instancian directamente)		❌ No puede tener constructores
Herencia		Una clase solo extiende 1 clase abs. (herencia simple)	Una clase puede implementar muchas interfaces (herencia múltiple)
Uso típico		Cuando querés un molde común con atrib y metodos		Para definir un contrato que varias clases distintas deben cumplir


✅ Resumiendo:

Usás clase abstracta cuando tenés un concepto general que comparte atributos y algunos métodos comunes.
Usás interfaz cuando querés un contrato (cierta obligacion de comportamiento) sin importar atributos ni herencia.
--------------------------------------------------------------------------------------------------------------------------------------

En Java un método static no puede ser abstract.
Razón: un método abstract no tiene cuerpo y debe implementarse en una subclase.

Un método static pertenece a la interfaz o clase misma, no a ninguna instancia ni subclase, así que no tiene sentido dejarlo sin implementación.


abstract = sin cuerpo → necesita implementación en subclase”
“static = pertenece a la interfaz/clase → ya tiene cuerpo, no necesita implementación”

--------------------------------------------------------------------------------------------------------------------------------------


En Java, el polimorfismo está diseñado para los métodos de instancia, no para los atributos.

Métodos de instancia	✅ Sí	Tiempo de ejecución (runtime, tipo dinámico del objeto)
Atributos			❌ No	Tiempo de compilación (compile-time, tipo léxico de la variable)
Métodos estáticos		❌ No	Compile-time, por la clase a la que se llame




con estas clases:
	----
class Animal {
    void sonido() { System.out.println("Sonido genérico"); }
}

class Perro extends Animal {
    @Override
    void sonido() { System.out.println("Guau"); }
}
	----

cuando hacemos esto:
	----
Animal a = new Perro();
a.sonido(); // 👉 "Guau" (se ejecuta el de Perro)
	----
sale guau, no sale sonido generico

	
--------------------------------------------------------------------------------------------------------------------------------------


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
🔹 1. Clase variable = new Clase(); ✅ (lo más simple)

Esto es lo normal y directo:

La variable es del mismo tipo que el objeto que instanciás.

Podés usar todos los atributos y métodos de la clase.

Ejemplo:
	----
Perro p = new Perro();
p.ladrar();  // ✅ se puede
	----
👉 Nada de polimorfismo acá, solo instanciación directa.

🔹 2. Subclase variable = new Subclase(); ✅

Esto también es muy simple:

La variable es de tipo subclase, y el objeto también.

Acceso completo a todo lo que tenga la subclase (incluyendo lo heredado de la superclase).

Ejemplo:


class Animal { void mover() {} }
class Perro extends Animal { void ladrar() {} }

Perro p = new Perro();
p.ladrar(); // ✅ propio de Perro
p.mover();  // ✅ heredado de Animal


👉 Igual que el caso anterior, pero con herencia de por medio.

🔹 3. Superclase variable = new Superclase(); ✅

Ahora con herencia:

La variable es de tipo superclase y el objeto también.

Solo podés acceder a lo definido en la superclase.

Si la superclase es abstracta → ❌ no podés instanciarla.

Ejemplo:


Animal a = new Animal();
a.mover(); // ✅
a.ladrar(); // ❌ no existe en Animal

👉 Directo, pero ojo: si Animal es abstracta, esto no se puede.

🔹 4. Superclase variable = new Subclase(); ✅ (el más interesante: polimorfismo)

Este es el patrón típico de polimorfismo en Java:

La variable es del tipo superclase.

El objeto real es de tipo subclase.

Podés solo acceder a lo definido en la superclase, PERO si un método fue sobrescrito, se ejecuta el de la subclase real.

Ejemplo:

Animal a = new Perro();
a.mover();   // ✅ método de Animal, pero si Perro lo sobrescribe se ejecuta el de Perro
// a.ladrar(); // ❌ no compila, porque "ladrar" no existe en Animal


👉 Acá está la potencia: podés manejar distintos tipos de subclases con una sola referencia de superclase.

🔹 Resumen en orden de simple a complejo

Clase variable = new Clase();
→ instanciación directa, acceso completo.

Subclase variable = new Subclase();
→ igual que arriba, con herencia incluida.

Superclase variable = new Superclase();
→ válido salvo que la superclase sea abstracta.

Superclase variable = new Subclase();
→ polimorfismo: referencia de superclase, objeto real de subclase.

👉 ¿Querés que te arme un ejemplo con código donde aparezcan los 4 casos juntos, para ver lado a lado cómo compilan y qué se puede hacer en cada uno?


class Animal {
    void mover() {
        System.out.println("El animal se mueve");
    }
}

class Perro extends Animal {
    @Override
    void mover() {
        System.out.println("El perro corre");
    }

    void ladrar() {
        System.out.println("¡Guau!");
    }
}

public class Test {
    public static void main(String[] args) {
        
        // 1) Clase = Clase (directo)
        Animal a1 = new Animal();
        a1.mover(); // "El animal se mueve"
        // a1.ladrar(); ❌ ERROR, no existe en Animal
        
        // 2) Subclase = Subclase
        Perro p1 = new Perro();
        p1.mover();  // "El perro corre" (override)
        p1.ladrar(); // "¡Guau!" (propio de Perro)
        
        // 3) Superclase = Superclase
        Animal a2 = new Animal();
        a2.mover(); // "El animal se mueve"
        // a2.ladrar(); ❌ no existe en Animal
        
        // 4) Superclase = Subclase (polimorfismo)
        Animal a3 = new Perro();
        a3.mover();  // "El perro corre" (se ejecuta el de Perro)
        // a3.ladrar(); ❌ no compila (no está en Animal)
        
        // Si quiero ladrar desde a3, necesito casting:
        ((Perro)a3).ladrar(); // "¡Guau!"
    }
}




🔹 Explicación rápida de cada caso

Clase = Clase

Instanciación directa.

Nada raro, acceso total a lo que define la clase.

Subclase = Subclase

Lo más flexible: acceso a métodos heredados y propios.

Superclase = Superclase

Solo acceso a lo de la superclase.

Nada polimórfico.

Superclase = Subclase (polimorfismo)

La variable solo “ve” lo de la superclase.

Pero si un método está sobrescrito, en ejecución corre la versión de la subclase.

💡 Regla de oro:

Atributos y métodos estáticos → se resuelven por el tipo de la variable (léxico).

Métodos de instancia sobrescritos → se resuelven por el tipo real del objeto (dinámico).



