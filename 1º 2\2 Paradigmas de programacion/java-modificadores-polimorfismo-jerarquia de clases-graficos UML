Caracteres Ãºtiles
â†’
--------------------------------------------------------------------------------------------------------------------------------------

Modificadores
Â¿Usa static?	Tipo de atributo						Modificadores posibles
SÃ­ (static)	De clase (uno solo, compartido por todos los objetos)		private, protected, public, default
No (static)	De instancia (cada objeto tiene su copia)			private, protected, public, default


âœ… Entonces:

static 				decide si es de clase o de instancia.
private/protected/public 	deciden la visibilidad, de mas a menos estricto.

final				define valor constante (por convencion los nombres de las ctes van en MAYUSCULA y espacios con un _ )
				ej:	static public final AÃ‘O_ACTUAL = 2025

--------------------------------------------------------------------------------------------------------------------------------------


OBJETOS: ES-UN vs TIENE-UN
ES-UN (auto es un vehiculo) 		(es un tipo de otro) (se refleja con extends, osea superclase y subclase)
TIENE-UN (vehiculo tiene un dueÃ±o) 	(tiene otro como parte de sÃ­ mismo.) (atributo dentro de la clase.)

--------------------------------------------------------------------------------------------------------------------------------------
INTERFACES:

//definimos o declaramos la interface:

public interface NombreDeLaInterface {
    // mÃ©todos abstractos (solo firmas, sin cuerpo) (SI O SI Nombre, tipo de retorno, y lista de parametros (tipo de parametro y nombre en orden))
    void metodo1();
    int metodo2(String parametro);
}




//la clase "Implementa" la interface:

public class Clase implements Interface{
	@Override
	public void metodoFirmadoEnInterface() {
}



@Override solo va en mÃ©todos que estÃ¡s implementando o sobrescribiendo (de una interface o superclase).
--------------------------------------------------------------------------------------------------------------------------------------

@Override:
Override = sobreescribir.

Cuando por herencia una sub sobreescribe un metodo de una super, u otra sub o super sobreescribe el de la interface implementada
se puede escribir en el renglon anterior @Override (la O con mayuscula). No es obligatorio pero recomendable porque sirve para
que el compilador nos avise de posibles errores en el nombre del metodo a sobreescribir.
--------------------------------------------------------------------------------------------------------------------------------------

QuÃ© es el tipo lÃ©xico?

Tipo lÃ©xico (o estÃ¡tico, declarado):
Es el tipo que vos escribÃ­s a la izquierda cuando declarÃ¡s la variable.
Se conoce en tiempo de compilaciÃ³n.
Define quÃ© mÃ©todos y atributos son accesibles sin casting.

Tipo dinÃ¡mico (o real):
Es el tipo del objeto creado con new (a la derecha).
Se conoce en tiempo de ejecuciÃ³n.
Define quÃ© implementaciÃ³n se ejecuta cuando un mÃ©todo estÃ¡ sobrescrito.

	Ejemplo con tu jerarquÃ­a:

	Encomienda encomienda = new Contrareembolso();

	Tipo lÃ©xico: Encomienda
	Tipo dinÃ¡mico: Contrareembolso
	
--------------------------------------------------------------------------------------------------------------------------------------


Los grÃ¡ficos que muestran clases y flechas entre ellas se llaman diagramas de clases UML (Unified Modeling Language).
Son parte de UML, un estÃ¡ndar visual para representar sistemas orientados a objetos.

Las flechas suelen indicar herencia (generalizaciÃ³n/especializaciÃ³n) o implementaciÃ³n de interfaces.

ğŸ“Œ En UML:

Una flecha con triÃ¡ngulo blanco apuntando hacia arriba indica herencia:

Contrareembolso â”€â–· Encomienda â”€â–· Envio significa que Contrareembolso extends Encomienda, y Encomienda extends Envio.

Una lÃ­nea punteada con triÃ¡ngulo blanco significa implementaciÃ³n de interfaz.




Mini-diagrama UML de tu caso:

	â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
	â”‚   Envio         â”‚  <<abstract>>
	â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		 â–²
		 â”‚
	â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
	â”‚  Encomienda     â”‚
	â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
		 â–²
		 â”‚
	â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
	â”‚ Contrareembolso â”‚
	â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


----------	otra info	------------
https://catedu.github.io/poo-java/jerarqua_de_clases.html

 
--------------------------------------------------------------------------------------------------------------------------------------

Clase Abstracta:

	Una clase abstracta es un molde incompleto.
	No se puede instanciar.
	Puede tener mÃ©todos abstractos y normales.
	Sirve para generalizar y aprovechar herencia + polimorfismo.

Â¿En una interfaz el mÃ©todo tambiÃ©n puede ser abstracto?
	SÃ­, todos los mÃ©todos en una interfaz son abstractos por defecto (a menos que sean default o static).
	Por eso no se escribe abstract, es implÃ­cito.

Â¿La clase abstracta puede tener atributos?
	SÃ­. Una clase abstracta puede tener atributos, mÃ©todos concretos (con cuerpo), y mÃ©todos abstractos (sin cuerpo).

Â¿Los mÃ©todos abstract deben ser sÃ­ o sÃ­ implementados en las subclases?
	Exacto. La idea principal es esa: obligar a las subclases a dar su propia implementaciÃ³n.
	Si no implementÃ¡s el mÃ©todo, la subclase tambiÃ©n debe ser abstracta.

Â¿Una clase abstracta sÃ­ o sÃ­ debe tener una subclase?
	En la prÃ¡ctica, sÃ­ (porque si no, nunca podrÃ­as instanciar nada de esa jerarquÃ­a).
	Pero el compilador no te obliga a crear una subclase; simplemente, si no lo hacÃ©s, esa clase abstracta queda â€œinutilizableâ€ por sÃ­ sola.

Â¿No se puede instanciar porque posee mÃ©todos sin cuerpo?
	SÃ­, esa es la razÃ³n fundamental. serÃ­a imposible ejecutar el llamado a un mÃ©todo abstracto sin cuerpo

Â¿Si la clase posee un mÃ©todo abstracto, debe ser sÃ­ o sÃ­ abstracta? Correcto.
	abstract class Envio {
	    abstract double calcularImpuesto();


--------------------------------------------------------------------------------------------------------------------------------------

Clase abstracta vs Interfaz

CaracterÃ­stica	Clase abstracta								Interfaz
InstanciaciÃ³n	âŒ No se puede instanciar						âŒ No se puede instanciar
Atributos		âœ… Puede tener atrib (variables de instancia, normales)	âš ï¸ Solo constantes
MÃ©tods abstractos	âœ… Puede tener mÃ©todos abstractos					âœ… Son abstractos por defecto
MÃ©tods con cuerpo	âœ… SÃ­, puede tener mÃ©todos con cuerpo				âœ… Puede tener default y static con cÃ³digo
Constructores	âœ… Puede tener (pero no se instancian directamente)		âŒ No puede tener constructores
Herencia		Una clase solo extiende 1 clase abs. (herencia simple)	Una clase puede implementar muchas interfaces (herencia mÃºltiple)
Uso tÃ­pico		Cuando querÃ©s un molde comÃºn con atrib y metodos		Para definir un contrato que varias clases distintas deben cumplir


âœ… Resumiendo:

UsÃ¡s clase abstracta cuando tenÃ©s un concepto general que comparte atributos y algunos mÃ©todos comunes.
UsÃ¡s interfaz cuando querÃ©s un contrato (cierta obligacion de comportamiento) sin importar atributos ni herencia.
--------------------------------------------------------------------------------------------------------------------------------------

En Java un mÃ©todo static no puede ser abstract.
RazÃ³n: un mÃ©todo abstract no tiene cuerpo y debe implementarse en una subclase.

Un mÃ©todo static pertenece a la interfaz o clase misma, no a ninguna instancia ni subclase, asÃ­ que no tiene sentido dejarlo sin implementaciÃ³n.


abstract = sin cuerpo â†’ necesita implementaciÃ³n en subclaseâ€
â€œstatic = pertenece a la interfaz/clase â†’ ya tiene cuerpo, no necesita implementaciÃ³nâ€


